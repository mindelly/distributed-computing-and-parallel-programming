// Matrix_Mult_new.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
//
#define _CRT_SECURE_NO_WARNINGS
#include <cstdlib>
#include <iostream>
#include <cstdio>
#include <math.h>
#include "mpi.h"
#include <stdio.h>
const int N = 2; // размерность матрицы
int main(int argc, char* argv[])
{
	double t1, t2;
	

	int r, q, myid, numprocs;
	int i0;
	int* b, * c, * loc_a, * loc_c;
	int namelen;
	char processor_name[MPI_MAX_PROCESSOR_NAME];

	// Инициализация подсистемы MPI
	MPI_Init(&argc, &argv);

	t1 = MPI_Wtime();

	// Получить размер коммуникатора MPI_COMM_WORLD
	// (общее число процессов в рамках задачи)
	// Определение количества процессов в выполняемой параллельной программе
	MPI_Comm_size(MPI_COMM_WORLD, &numprocs);

	// Получить номер текущего процесса в рамках 
	// коммуникатора MPI_COMM_WORLD
	// Для определения ранга процесса
	MPI_Comm_rank(MPI_COMM_WORLD, &myid);
	MPI_Get_processor_name(processor_name, &namelen);

	// Вывод номера потока в общем пуле
	fprintf(stdout, "Process %d of %d is on %s\n", myid, numprocs, processor_name);
	fflush(stdout);
	MPI_Status status;



	// q 
	q = N / numprocs;
	b = new int[N*N];
	c = new int[N*N];
	loc_c = new int[N*N];
	loc_a = new int[q];
	for (int i = 0; i < N*N; i++)
	{
		c[i] = 0;
		loc_c[i] = 0;
	}
	// если id потока 0 (?)
	if (myid == 0)
	{
		for (int j = 0; j < numprocs; j++)
		{
			for (r = 0; r < q*N; r++)
			{
				loc_a[r] = 1;
			}
			// MPI send: аргументы - 1) адрес буфера, из которого берутся данные; 
			// 2) размер буфера в кол-ве ячеек:
			// указывает, сколько ячеек требуется передать;
			// 3) тип ячейки буфера;
			// 4) номер задачи, с которой происходит обмен данными;
			// 5) идентификатор сообщения; это целое число от 0 до 32767, которое пользователь выбирает сам
			// 6) Описатель области связи (коммуникатор). Обязан быть одинаковым для MPI_Send и MPI_Recv.
			//MPI_Send(&loc_a[0], q*N, MPI_INT, j, 0, MPI_COMM_WORLD);
		}
		for (int i = 0;i < N * N;i++)
		{
			b[i] = 1;
		}
	}
	// MPI recv: аргументы - 1) адрес буфера, в который помеащются данные;
	// 2) размер буфера в кол-ве ячеек: в MPI_Recv означает максимальную емкость приемного буфера.
	// Если фактическая длина пришедшего сообщения меньше - последние ячейки буфера останутся нетронутыми, если больше - произойдет ошибка времени выполнения.
	// 3) тип ячейки буфера;
	// 4) номер задачи, с которой происходит обмен данными;
	// 5) идентификатор сообщения; это целое число от 0 до 32767, которое пользователь выбирает сам
	// 6) Описатель области связи (коммуникатор). Обязан быть одинаковым для MPI_Send и MPI_Recv.
	// 7) Статус завершения приема. Содержит информацию о принятом сообщении: его идентификатор, номер задачи-передатчика, код завершения и количество фактически пришедших данных.
	MPI_Recv(&loc_a[0], q*N, MPI_INT, 0, 0, MPI_COMM_WORLD, &status);

	for (r = 0; r < N; r++)
	{
		// MPI_Bcast рассылает содержимое буфера из задачи, имеющей в указанной области связи номер root, во все остальные:
		// MPI_Bcast(buf, count, dataType, rootRank, communicator);
		// относится к функциям коллективного обмена данными
		MPI_Bcast(&b[r*N], N, MPI_INT, 0, MPI_COMM_WORLD);

		i0 = myid * q;

		for (int i = 0; i < q; i++)
		{
			for (int j = 0;j < N;j++)
			{
				loc_c[r*N + i0] += loc_a[i*N + j] * b[r*N + j];
			}
			i0++;
		}
		// сборка данных
		MPI_Reduce(loc_c, c, N*N, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);
	}
	if (myid == 0)
	{
		FILE* f = fopen("result.txt", "wb");
		for (int i = 0; i < N; i++)
		{
			for (int j = 0; j < N; j++)
			{
				fprintf(f, "%d\t", c[j*N + i]);
			}
			fprintf(f, "\n");
		}
		fclose(f);
	}

	
	t2 = MPI_Wtime();
	printf("%e\n", t2 - t1);

	// Освобождение подсистемы MPI
	MPI_Finalize();

	return 0;
}


// Запуск программы: CTRL+F5 или меню "Отладка" > "Запуск без отладки"
// Отладка программы: F5 или меню "Отладка" > "Запустить отладку"

// Советы по началу работы 
//   1. В окне обозревателя решений можно добавлять файлы и управлять ими.
//   2. В окне Team Explorer можно подключиться к системе управления версиями.
//   3. В окне "Выходные данные" можно просматривать выходные данные сборки и другие сообщения.
//   4. В окне "Список ошибок" можно просматривать ошибки.
//   5. Последовательно выберите пункты меню "Проект" > "Добавить новый элемент", чтобы создать файлы кода, или "Проект" > "Добавить существующий элемент", чтобы добавить в проект существующие файлы кода.
//   6. Чтобы снова открыть этот проект позже, выберите пункты меню "Файл" > "Открыть" > "Проект" и выберите SLN-файл.
